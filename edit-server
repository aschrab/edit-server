#!/usr/bin/env python
# Copyright (C) 2009  David Hilley <davidhi@cc.gatech.edu>,
# Tim Cuthbertson <gfxmonk.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
import cgi, urlparse
import subprocess
import tempfile, time
import os, sys, re
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from SocketServer import ThreadingMixIn
import threading
import logging
import time
logging.basicConfig(level=logging.DEBUG, format="%(levelname)s: %(message)s [%(threadName)s@%(asctime)s]")

open_cmd = ['gvim', '-f']
delay_in_minutes = 5
os.environ['FROM_EDIT_SERVER'] = 'true'

class HttpError(RuntimeError):
	pass

class Handler(BaseHTTPRequestHandler):
	def do_GET(self):
		if self.path == '/status':
				self.send_response(200)
				self.send_header('Content-Type', 'text/plain; charset=utf-8')
				self.end_headers()
				self.wfile.write('edit-server is running.\n')
				return
		self.send_error(404, "GET Not Found: %s" % self.path)

	def _make_temp_file(self, contents):
		prefix = "chrome_"
		f = tempfile.NamedTemporaryFile(delete=False, prefix=prefix, suffix='.txt')
		fname = f.name
		f.write(contents)
		f.close()
		return fname

	def _wait_for_edited_contents(self, filename):
		# spawn editor...
		logging.info("Spawning editor... %s" % (filename,))
		p = subprocess.Popen(open_cmd + [filename], close_fds=True)

		# hold connection open until editor finishes
		retcode = p.wait()
		success = retcode == 0

		if success:
			with open(filename, 'r') as f:
				return f.read()
		else:
			if rc > 0:
				msg = 'text editor returned %d' % rc
			elif rc < 0:
				msg = 'text editor died on signal %d' % -rc
			raise HttpError(404, msg)
	
	def _respond(self, contents):
		self.send_response(200)
		self.end_headers()
		self.wfile.write(contents)

	def _delayed_remove(self, filename):
		def delayed_remove():
			logging.debug("sleeping %s mins" % (delay_in_minutes,))
			time.sleep(delay_in_minutes * 60)
			logging.debug("removing file: %s" % (filename,))
			try:
				os.unlink(filename)
			except :
				logging.error("Unable to unlink: %s" % (filename, ))
		thread = threading.Thread(target=delayed_remove)
		thread.daemon = True
		thread.start()

	def do_POST(self):
		try:
			content_length = self.headers.getheader('content-length')
			if content_length is None:
				self.send_response(411)
				self.end_headers()
				return
			content_length = int(content_length)
			body = self.rfile.read(content_length)
			filename = self._make_temp_file(body)
			contents = self._wait_for_edited_contents(filename)
			self._respond(contents)
			self._delayed_remove(filename)
		except HttpError, e:
			self.send_error(*e.args)
		except Exception, e:
			logging.error("Error: %s" % (e,))
			self.send_error(404, "Not Found: %s" % self.path)
		logging.debug("POST complete")

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
	pass

def main():
	global delay_in_minutes
	try:
		port = int(os.environ.get('EDIT_SERVER_PORT', 9292))
		delay_in_minutes = float(os.environ.get('EDIT_SERVER_DELAY', 5))
		httpserv = ThreadedHTTPServer(('localhost', int(port)), Handler)
		httpserv.table = {}
		logging.info('edit-server started on port %s' % (port,))
		httpserv.serve_forever()
	except KeyboardInterrupt:
		httpserv.socket.close()

if __name__ == '__main__':
	args = sys.argv[1:]
	if args:
		open_cmd = args
	main()


